/*
 * BCM.c
 *
 *  Created on: Mar 2, 2020
 *      Author: Youssef Harby
 */


#include "BCM.h"
#include "BCM_cfg.h"


#define UNDETERMINED		0x00


static volatile uint8_t gu8_BCM_UART_SM;
static volatile uint8_t gu8_BCM_SPI_SM;

uint8_t gu8_TxFlag = 0;

strBcmStartConfig_t BCM_startCfg = {
		0,
		0,
		0
};

void app(void)
{
	gu8_TxFlag = 1;
}


EnmBCMError_t BCM_Init(const strBcmConfig_t* ConfigPtr)
{
	uint8_t au8_Ret = E_OK;
	PointerToCallBackFunction apf_UART_CallBackPtr = NULL;
	PointerToCallBackFunction apf_SPI_CallBackPtr = NULL;

	UART_ConfigType UART_cfg = {
			UART_ASYNCHRONOUS_MODE,
			UNDETERMINED,
			UART_EIGHT_BITS,
			UART_PARITY_DISABLED,
			UART_ONE_STOP_BIT,
			UART_INTERRUPT_ENABLED
	};

	SPI_ConfigType SPI_cfg = {
			UNDETERMINED,
			SPI_INTERRUPT_ENABLED,
			SPI_F_OSC_4
	};

	switch(ConfigPtr->BCM_DataDirection)
	{
	case BCM_TRANSMIT:
		apf_UART_CallBackPtr = UART_TXC_setCallBack;
		apf_SPI_CallBackPtr = SPI_setCallBack;
		UART_cfg.communicationMode = UART_SENDER_MODE;
		SPI_cfg.MasterSlaveSelect = SPI_MASTER;
		break;
	case BCM_RECEIVE:
		apf_UART_CallBackPtr = UART_RXC_setCallBack;
		apf_SPI_CallBackPtr = SPI_setCallBack;
		UART_cfg.communicationMode = UART_RECEIVER_MODE;
		SPI_cfg.MasterSlaveSelect = SPI_SLAVE;
		break;
	case BCM_TRANSMIT_RECEIVE:
		UART_cfg.communicationMode = UART_SENDER_RECEIVER_MODE;
		break;
	default:
		au8_Ret = E_NOK;
		break;
	}

	switch(ConfigPtr->BCM_ProtocolID)
	{
	case BCM_UART_ID:
		apf_UART_CallBackPtr(&app);
		UART_init(&UART_cfg);
		gu8_BCM_UART_SM = (uint8_t)BCM_IDLE;
		break;
	case BCM_SPI_ID:
		apf_SPI_CallBackPtr(&app);
		SPI_init(&SPI_cfg);
		gu8_BCM_SPI_SM = (uint8_t)BCM_IDLE;
		break;
	default:
		au8_Ret = E_NOK;
		break;
	}

	return au8_Ret;
}

EnmBCMError_t BCM_DeInit(uint8_t BCM_ProtocolID)
{
	uint8_t au8_Ret = E_OK;

	switch(BCM_ProtocolID)
	{
	case BCM_UART_ID:
		UART_deInit();
		UART_RXC_setCallBack(NULL);
		UART_TXC_setCallBack(NULL);
		gu8_BCM_UART_SM = (uint8_t)BCM_UNINITIALIZED;
		break;
	case BCM_SPI_ID:
		SPI_deInit();
		SPI_setCallBack(NULL);
		gu8_BCM_SPI_SM = (uint8_t)BCM_UNINITIALIZED;
		break;
	default:
		au8_Ret = E_NOK;
		break;
	}

	return E_OK;
}

EnmBCMError_t BCM_RxDispatch(void)
{


	return E_OK;
}

EnmBCMError_t BCM_TxDispatch(void)
{
	if(gu8_TxFlag == 1)
	{
		gu8_TxFlag = 0;

		BCM_Send(&BCM_startCfg);
	}

	return E_OK;
}

EnmBCMError_t BCM_Send(uint8_t ProtocolID, uint8_t* ArrayFirstElementAddress, uint8_t ArraySize)
{
	uint8_t au8_Ret = E_OK;
	static uint8_t au8_counter = 0;
	PointerToSenderFunction apf_SenderFunction = NULL;

	switch(ProtocolID)
	{
	case BCM_UART_ID:
		apf_SenderFunction = UART_transmit;
		gu8_BCM_UART_SM = BCM_SENDING_BYTE;
		break;
	case BCM_SPI_ID:
		apf_SenderFunction = SPI_sendByte;
		gu8_BCM_SPI_SM = BCM_SENDING_BYTE;
		break;
	default:
		au8_Ret = E_NOK;
		break;
	}

	if(au8_counter < ArraySize)
	{
		apf_SenderFunction(ArrayFirstElementAddress[au8_counter]);
		au8_counter++;
	}

	BCM_startCfg = *ConfigPtr;

	return E_OK;
}

EnmBCMError_t BCM_Receive(strBcmStartConfig_t* ConfigPtr)
{
	uint8_t au8_Ret = E_OK;
	static uint8_t au8_counter = 0;
	PointerToReceiverFunction apf_ReceiverFunction = NULL;

	switch(ConfigPtr->BCM_ProtocolID)
	{
	case BCM_UART_ID:
		apf_ReceiverFunction = UART_receive;
		gu8_BCM_UART_SM = BCM_SENDING_BYTE;
		break;
	case BCM_SPI_ID:
		apf_ReceiverFunction = SPI_receiveByte;
		gu8_BCM_SPI_SM = BCM_SENDING_BYTE;
		break;
	default:
		au8_Ret = E_NOK;
		break;
	}

	if(au8_counter < ConfigPtr->BCM_ArraySize)
	{
		ConfigPtr->BCM_ArrayStartAddress[au8_counter] = apf_ReceiverFunction();
		au8_counter++;
	}

	return E_OK;
}
